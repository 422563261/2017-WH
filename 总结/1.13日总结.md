## 1.13日总结

### js

1. 数据类型分为: Undefined,Null,Number,Boolean,String

2. toString()这个方法Null和Undefined没有，可以通过String()实现。String()具体实现方式为先检测值是否有toString()这个方法，若没有，则返回对应的"null"和"undefined"
3. function(x,y) x,y可以用arguments来调用
4. 检测基本数据用typeof，检测引用类型用instanceof
5. js垃圾回收的方式有两种：标记清除、引用计数(循环引用出bug，淘汰)
6. 局部变量可以脱离环境，全局变量需要通过设置null来释放引用，这叫解除引用
7. 每次进入一个新执行环境，都会创建一个用于搜索变量的函数作用域链
8. 推荐使用对象字面量方法创建Object实例，推荐使用点对法访问对象属性
9. 当把一个值放在超出当前数组大小的位置上时，数组就会重新计算其长度值，即长度值等于最后一项的索引加1
10. 检测是否为数组可以用a instanceof Array，不过最好用Array.isArray(a)
11. 栈方法push()推入，pop()推出，得到数组末位
12. 队列方法push()推入，shift()推出，得到数组首位
13. push()推入到尾部，unshift()推入到头部
14. 不带参数的sort()比较的是字符串，因此无法数值。可以使用带比较函数的sort(compare) //function compare(v1,v2){return v1-v2}
15. toString()、join()、valueOf()效果基本一致。区别在于，转化数组的时候valueOf()会保留属性为Array，join()可以自定义分隔符
16. slice(v1,v2) v1，v2分别是起始位置和结束位置，但分割出来的不包括v2
17. slice()中的负数参数处理方法：加上数组长度转化为正数
18. splice(v1,v2,v3,v4…) v1起始位置 v2删除项数 v3，v4…添加内容
19. indexOf(v1,v2) v1查找项 v2起始位置 未找到返回-1
20. indexOf(v1,v2) 从v2左往右遍历，找到v1第一次出现的位置,返回值是从左数过来
21. lastIndexOf(v1,v2) 从v2右往左扫描，找到v1最后一次出现的位置,返回值也是从左数过来
22. 了解every(),filter(),forEach(),map(),some()迭代方法
23. 了解reduce(),reduceRight()归并方法
24. Date(2005,4,5,17,55,55) 2005年5月5日17:55:55
25. Date.now()获取当前毫秒==(new Date()).valueOf()==(new Date()).getTime()
26. getFullYear(年) getMonth(月) getDate(日) getDay(星期) getHours(时) getMinutes(分) getSeconds(秒)
27. 了解RegExp类型 
28. arguments.callee()可以调用函数本身
29. arguments.callee.caller可以调用函数本身源码
30. 使用apply()，call()来扩充作用域的好处，就是对象不需要与方法有任何耦合
31. slice和substring接收的是起始位置和结束位置(不包括结束位置)，而substr接收的则是起始位置和所要返回的字符串长度。substring是以两个参数中较小一个作为起始位置，较大的参数作为结束位置。接着，当接收的参数是负数时，slice会将它字符串的长度与对应的负数相加，结果作为参数；substr则仅仅是将第一个参数与字符串长度相加后的结果作为第一个参数；substring则干脆将负参数都直接转换为0。
32. toFixed(x) x为小数保留的位数，四舍五入，适合处理货币
33. toPrecision(x) x为整个数字保留的位数，四舍五入

		var a = "123";
		var b = new Num(123);
		typeof a; //"number"
		typeof b; //"object"
		a instanceof Number; //false
		b instanceof Number; //true
34. 以上为引用类型与基本包装类型的区别，Boolean同理
35. charAt(v1) 获取v1位置的字符值 <br> indexOf(v2) 是获取字符值为v2的位置
36. trim()方法可以删除前缀和后缀空格，比如说用于用户名格式清理
37. 字符串匹配方法match()与exec()方法相似<br>String.match(RegExp)<br>RegExp.exec(String)
38. 字符串匹配方法search()与test()方法相似，区别见上一条
39. 字符串匹配方法replace()类似于splice()与exec()的结合，按正则寻找并替换<br>String.replace(RegExp,value)
40. split(x) 以x为界限分割字符串
41. encodeURLComponent()，decodeURLComponent()
42. Math.min()，Math.max()，Math.floor()，Math.ceil()，Math.round()，Math.random()
43. Object.defineProperty(obj,name,{})<br>数据属性：configurable是否可删除、enumerable是否通过for-in遍历出来、writable是否可修改、value属性值
44. Object.defineProperties(obj,{})一次性定义多个属性
45. hasOwnProperty() 若为true则属性来自实例，反之来自原型
46. Object.getOwnPropertyDescriptor()方法只能用于实例属性，若要取得原型属性的描述符，必须直接在原型对象上调用
47. 单独使用in会在通过对象能够访问给定属性时返回true，不论属性来自实例还是原型。可搭配hasOwnProperty()判断属性来自实例还是原型
48. for-in循环返回的是所有能够通过对象访问的、可枚举的属性，实例+原型。但是即使是不可枚举的依然会遍历出来。
49. Object.keys()返回的是当前对象的可枚举的属性，不包括原型。
50. 原型定义可以用o.prototype.属性<br>还可以用对象字面量o.prototype = {} 这样非常美观，但有一个缺点，constructor不指向o。因为每创建一个函数，就会生成一个新的constructor，这里相当于重写了o.prototype。<br>o.prototype = {constructor:o,...}这样不可行的原因是通过对象字面量创建，数据属性会默认为true<br>解决办法：o.defineProperty(o.prototype,"constrtuctor",{value:"constructor"})默认为false
51. 构造函数：工厂模式，原型模式，动态原型模式，寄生构造模式，稳妥构造模式
52. 继承：原型链，借用构造函数，组合继承，原型式继承，寄生式继承，寄生式组合继承
53. 函数声明会提升变量，函数表达式不会
54. 闭包只能获取包含函数中任何变量的最后一个值
55. 匿名函数的执行环境具有全局性，因此其this指向window，arguements也存在这个问题，必须将该对象的引用保存到另一个闭包能够访问的变量中
56. 匿名自执行函数用作块级作用域，在执行结束后，任何变量都会被销毁
57. 私有变量可以理解为局部变量，通过闭包的作用域链访问。这种把有权访问私有变量和私有函数的公有方法称为特权方法